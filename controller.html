<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>NIKE</title>
<meta name="viewport" content="width=device-width, initial-scale=0.7, maximum-scale=0.7", user-scalable="no">
<link rel="stylesheet" href="css/reset.css" type="text/css">
<link rel="stylesheet" href="css/style.css" type="text/css">
<script src="http://code.jquery.com/jquery-1.11.2.min.js"></script>
<script src="http://code.jquery.com/jquery-migrate-1.2.1.min.js"></script>
<script type="text/javascript" src="js/data.js"></script>
<script type="text/javascript" src="js/plugins.js"></script>
<style type="text/css">
body, html{ width:100%; height:100%; }
.controller{ width:100%; display:block; position:absolute; left:80%; top:20%; }
.controller .inside{ position:relative; width:100%; }

</style>
</head>
<body>

<div class="controller">
	<div class="inside">
    	<canvas id="Controller" width="640" height="640"></canvas>
        <h2 class="slogan">KALKMASINA DESTEK OL<small>Oku Ã§ek</small></h2>
    </div>
</div>    

<script type="text/javascript">


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  GLOBAL VARIABLE 

var win = $(window), doc = $(document), wt = parseFloat( win.width() ),  ht = parseFloat( win.height() ), wst = parseFloat( win.scrollTop() ), sRatio = 0, scene, container, el = $('.wrapper'), preloading = $('.preloading'), timeline = $('.timeline'), imgW = 640, imgH = 360, canvas = $('#Controller'), update = true, SCALEX = 1, SCALEY = 1;

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// CANVAS SETTING

	scene = new createjs.Stage('Controller');
	container = new createjs.Container();
	scene.addChild( container );
	createjs.Ticker.setFPS( 30 );
	createjs.Touch.enable( scene );
	scene.enableMouseOver(10);
	scene.mouseMoveOutside = true;
	
	
	createjs.Ticker.addEventListener('tick', tick);
	function tick( event ){
		if( update ){
			update = false;
			scene.update( event );
		}
	}
	function stop(){
		createjs.Ticker.removeEventListener('tick', tick);
	}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// MATH FUNC.
var MATH = {
	
	keyCount : function(o) {
        if( typeof o == 'object' ){
            var i, count = 0;
            for( i in o ) {
                if( o.hasOwnProperty( i ) ){
                    count++;
                }
            }
            return count;
        } else {
            return false;
        }
    },
	
	getDistance: function( x1, y1, x2, y2 ){
		var dx = x2 - x1, dy = y2 - y1;
	    return Math.abs( Math.sqrt( dx * dx + dy * dy ) );	
	},
	
	getCurvePoints: function( ptsa, tension, numOfSegments ){
		
		tension = (tension != 'undefined') ? tension : 0.5;
		numOfSegments = numOfSegments ? numOfSegments : 16;
		
		var _pts = [],
			res = [], // clone array and result
			x, y, // our x,y coords
			t1x, t2x, t1y, t2y, // tension vectors
			c1, c2, c3, c4, // cardinal points
			st, st2, st3, st23, st32, // steps
			l, t, i; // steps based on num. of segments
		
		_pts = ptsa.concat();
		_pts.unshift( ptsa[ 1 ] );
		_pts.unshift( ptsa[ 0 ] );
		_pts.push( ptsa[ ptsa.length - 2 ] );
		_pts.push( ptsa[ ptsa.length - 1 ] );
		
		l = ( _pts.length - 4 );
		for( i = 2; i < l; i += 2 ){
			for( t = 0; t <= numOfSegments; t++ ){
		
				// calc tension vectors
				t1x = ( _pts[ i + 2 ] - _pts[ i - 2 ] ) * tension;
				t2x = ( _pts[ i + 4 ] - _pts[ i ] ) * tension;
		
				t1y = ( _pts[ i + 3 ] - _pts[ i - 1 ] ) * tension;
				t2y = ( _pts[ i + 5 ] - _pts[ i + 1 ] ) * tension;
		
				// pre-calc step
				st = t / numOfSegments;
				st2 = st * st;
				st3 = st2 * st;
				st23 = st3 * 2;
				st32 = st2 * 3;
		
				// calc cardinals
				c1 = st23 - st32 + 1;
				c2 = -( st23 ) + st32;
				c3 = st3 - 2 * st2 + st;
				c4 = st3 - st2;
		
				// calc x and y cords with common control vectors
				x = c1 * _pts[ i ] + c2 * _pts[ i + 2 ] + c3 * t1x + c4 * t2x;
				y = c1 * _pts[ i + 1 ] + c2 * _pts[ i + 3 ] + c3 * t1y + c4 * t2y;
		
				//store points in array
				res.push({ 'x': x, 'y': y });
				
			}
		}
		
		return res;
	
	}

};


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// CREATEJS DASHED STROKE
(createjs.Graphics.StrokeDash = function( segments, offset ){
    this.segments = segments;
    this.offset = offset;
}).prototype.exec = function( ctx ){
    ctx.setLineDash( this.segments );
    ctx.lineDashOffset = this.offset;
};
createjs.Graphics.prototype.setStrokeDash = function( segments, offset ){
    return this.append( new createjs.Graphics.StrokeDash( segments, offset ) );
};


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// PRELOADER
(function(window){
	
	function Preloader( obj, callback ){
		
		var preload = new createjs.LoadQueue( true );
			preload.on('progress', handleProgress);
			preload.on('complete', handleComplete);
			preload.on('fileload', handleFileLoad);
			preload.loadManifest( obj, true );
		
		function handleProgress( e ){
			callbackDetect( {'type': 'progress', 'value': e.loaded } );
		}
		
		function handleFileLoad( e ){
			// nothing
		}
		
		function handleComplete( e ){
			callbackDetect( {'type': 'complete', 'value': e['target'] } );
			if( preload != null ){
				preload.close();
				preload = null;
			}
		}
		
		function callbackDetect( obj ){
			if( callback != undefined && obj != undefined ) callback( obj );
		}			
		
	};
	
	window.Preloader = Preloader;
	
})(window);


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// SVG TO ARRAY
function convertToArr( o ){
	var path = document.createElementNS('http://www.w3.org/2000/svg', 'path'), len = 0, arr = [];
		path.setAttribute('d', o);
	len = path.getTotalLength();	
	for( var i = 0; i <= 100; ++i ){
		var o = path.getPointAtLength( len * i / 100 );
		arr.push( o['x'] );
		arr.push( o['y'] );
	}
	return arr;		
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// CONTROLLER


(function(window){
	
	function Controller( o, callback ){
		var con = new createjs.Container(), pathData = convertToArr( o['path']['d'] ), points = MATH.getCurvePoints( pathData, .5 ), ln, le = points.length - 1, rate = 0, dir = o['direction'] || 'bottom', cPoint = o['controlPoint'] || .9;
		
		con.y = 0;
		con.x = 0;
		con.scaleX = SCALEX;
		con.scaleY = SCALEY;		
				
		scene.addChild( con );
			
		function init(){
			ln = drawLine()
			add( ln );
			new Preloader( o['manifest'], function( k ){ if( k['type'] == 'complete' ) complete( k['value'] ); });
		}
	
		function complete( obj ){
			var o = obj['_loadedResults'];
			if( o['start'] != undefined ) add( drawBitmap( { 'img': o['start'], 'type': 'static', 'name': 'start', 'coor':{ 'x': points[ 0 ]['x'], 'y': points[ 0 ]['y'] } } ) );
			if( o['end'] != undefined ) add( drawBitmap( { 'img': o['end'], 'type': 'static', 'name': 'end', 'coor':{ 'x': points[ le ]['x'], 'y': points[ le ]['y'] } } ) );
			if( o['drag1'] != undefined ){
				if( dir == 'bottom' || dir == 'right' )
					add( drawBitmap( { 'img': o['drag1'], 'type': 'drag', 'name': 'drag', 'coor':{ 'x': points[ le ]['x'], 'y': points[ le ]['y'] } } ) );
				else if( dir == 'top' || dir == 'left' )
					add( drawBitmap( { 'img': o['drag1'], 'type': 'drag', 'name': 'drag', 'coor':{ 'x': points[ 0 ]['x'], 'y': points[ 0 ]['y'] } } ) );
			}
		}
		
		function drawBitmap( o ){
			var b = new createjs.Bitmap( o['img'] ), w = b.image.width, h = b.image.height;
				b.x = o['coor']['x'];
				b.y = o['coor']['y'];
				b.regX = w * .5 | 0;
				b.regY = h * .5 | 0;
				b.name = o['name'];
				
				// EVENT
				if( o['type'] == 'drag' ){
					b.cursor = 'pointer';			
					b.hitArea = new createjs.Shape( new createjs.Graphics().beginFill("#f00").drawRect( -w * .5, -h * .5, w * 2, h * 2 ) );
					dragEvents( b );
				}
			
			return b;	
		}
		
		function dragEvents( el ){
			
			var rX = 1 / SCALEX, rY = 1 / SCALEY;
			
			el.draggable = true;
			
			/*
			el.on('click', function( evt ){
				rate = ( dir == 'bottom' || dir == 'right' ) ? 1 : 0;
			});
			*/
			
			el.on('mousedown', function( evt ){				
				if( this.draggable )
					this.offset = { x: this.x - ( evt.stageX * rX ), y: this.y - ( evt.stageY * rY ) };
				else return false;
				
			});
		
			el.on('pressmove', function( evt ){
				
				if( this.draggable ){
				
					update = true;
					
					var x = ( evt.stageX * rX ) + this.offset.x,	y = ( evt.stageY * rY ) + this.offset.y, pIndex = -1, minDist = 999999999, dist;
					
					for( var i = 0; i < le; i += 2 ){
						dist = MATH.getDistance( x, y, points[ i ]['x'], points[ i ]['y'] );
						if( dist < minDist ){
							minDist = dist;
							pIndex = i;
						}
					}
					
					this.x = points[ pIndex ]['x'];
					this.y = points[ pIndex ]['y'];
					this.rotation = Math.atan2( points[ pIndex ]['y'] - y, points[ pIndex ]['x'] - x ) * 180 / Math.PI;
	
					/*var p = [];
						p[ 0 ] = points[ pIndex - 1 ];
						p[ 1 ] = points[ pIndex + 1 ];
					if( p[ 0 ] != undefined && p[ 1 ] != undefined ){
						var angle = Math.atan2( p[ 1 ].y - p[ 0 ].y, p[ 1 ].x - p[ 0 ].x ) * 180 / Math.PI;
						this.rotation = angle;
					}*/
					
					
					rate = pIndex / le;
					callbackDetect( rate );
				}
				
			});
			
			el.on('pressup', function( evt ){
				if( this.draggable ){
					checkControlPoint( el, rate );
				}
			});
	
			el.on('rollover', function( evt ){
				update = true;
			});
	
			el.on('rollout', function( evt ){
				update = true;
			});
			
		}
		
		function checkControlPoint( el, rate ){
			
			var _this = this, k = 0, r = ( dir == 'bottom' || dir == 'right' ) ? 1 - cPoint : cPoint;
				_this.value = rate;
			
			callbackDetect( rate );
				
			if( dir == 'bottom' || dir == 'right' ){
				if( rate <= r ) k = 0;
				else k = 1;
			}else{
				if( rate >= r ) k = 1;
				else k = 0;
			}
		
			createjs
			.Tween
			.get( _this )
			.to({ value: k }, 555)
			.call(function(){
				// complete
				if( ( ( dir == 'bottom' || dir == 'right' ) && k == 0 ) || ( ( dir == 'top' || dir == 'left' ) && k == 1 ) ) el.draggable = false;
				callbackDetect( rate );
			})
			.addEventListener('change', function(){
				var o = points[ Math.round( _this.value * le ) ];
				if( o != undefined ){
					el.x = o['x'];
					el.y = o['y'];
					update = true;
				}
				
				rate = _this.value;
				callbackDetect( rate );
			});
			
		}
		
		function drawLine(){
			var line = new createjs.Shape(), stroke = o['path'];
				line.graphics.setStrokeStyle( stroke['style'] ).setStrokeDash( stroke['dash']['segment'], stroke['dash']['offset'] ).beginStroke( stroke['color'] );
				
			for( i = 0; i < le; i+=2 ){
				var x = points[ i ]['x'], y = points[ i ]['y'];
				if( i > 0 ) 
					line.graphics.lineTo( x, y );
				else 
					line.graphics.moveTo( x, y );
			}
			line.graphics.endStroke();
			
			return line;
		}
		
		function dynamicMasking( r ){
			var o = points[ Math.round( r * le ) ];
			var msk = new createjs.Shape();
				msk.graphics.beginFill("#ff0000").drawRect( 0, 0, 146, 307 ).arc( o['x'], o['y'], 19, 0, Math.PI * 2, true );
			
			ln.mask = msk;
		}
		
		function add( k ){
			con.addChild( k );
			update = true;
		}
		
		function callbackDetect( r ){
			dynamicMasking( r );
			if( callback != undefined ) callback({ 'rate': r });
		}
		
		init();
					
		// PUBLIC FUNC.
		this.adjust = function(){
		
		};
		this.destroy = function(){
		
		};
	};
	
	window.Controller = Controller;
	
})(window);


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// CANVAS

var maxCount = 2000;
new Controller( section['begin']['scrup']['controller'], function( o ){
							
	var dir = 'bottom', rate = o['rate'], cr = 0;
	if( dir == 'bottom' || dir == 'rigth' ) cr = Math.round( ( 1 - rate ) * maxCount );
	else if( dir == 'top' || dir == 'left' ) cr = Math.round( rate * maxCount );
	
	
	console.log( cr );
		
});







</script>

</body>
</html>
